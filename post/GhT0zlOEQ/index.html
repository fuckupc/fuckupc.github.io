<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>04.运算符 | Flash</title>
<meta name="description" content="I&#39;ve spent my whole life searching for the impossible. Never imagining that I would become the impossible. 
        --Barry Allen">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="shortcut icon" href="https://fuckupc.github.io/favicon.ico">
<link rel="stylesheet" href="https://fuckupc.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://fuckupc.github.io">
        <img src="https://fuckupc.github.io/images/avatar.png" class="site-logo">
        <h1 class="site-title">Flash</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="site-description">
      I've spent my whole life searching for the impossible. Never imagining that I would become the impossible. 
        --Barry Allen
    </div>
    <div class="site-footer">
      Powered by Hve Notes
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">04.运算符</h2>
            <div class="post-date">2019-03-13</div>
            
            <div class="post-content">
              <h1 id="前言">前言</h1>
<p>比如说<code>+</code>、<code>*</code>、<code>/</code>、<code>(</code> 都是<strong>运算符</strong>，而<code>（3+5）/2</code>则是<strong>表达式</strong>。</p>
<p><strong>运算符的定义和分类</strong>
运算符也叫操作符。通过运算符可以对一个或多个值进行运算，并获取运算结果。</p>
<p>比如：typeof 就是运算符，可以来获得一个值的类型。它会将该值的类型以<strong>字符串</strong>的形式返回：number string boolean undefined object。</p>
<p>注：运算符都是会返回结果的，而typeof这个运算符返回的结果就是变量的类型。那返回的结果的类型是什么呢？是字符串。</p>
<p>运算符有很多分类，比如：</p>
<p>算数运算符</p>
<p>自增运算符</p>
<p>逻辑运算符</p>
<p>赋值运算符</p>
<p>关系运算符</p>
<p>三元运算符（条件运算符）</p>
<p><strong>算数运算符</strong>
常见的算数运算符有以下几种：
<img src="https://fuckupc.github.io/post-images/1552477537282.png" alt="">
<strong>求余的举例：</strong>
假设用户输入345，怎么分别得到3、4、5这三个数呢？
答案：</p>
<pre><code>	得到3的方法：345 除以100，得到3.45然后取整，得到3。即：parseInt(345/100)
	得到4的方法：345 除以100，余数是45，除以10，得到4.5，取整。即：parseInt(345 % 100 / 10)
	得到5的方法：345 除以10，余数就是5。即：345 % 10
</code></pre>
<p><strong>算数运算符的运算规则</strong>
（1）先算乘除、后算加减。
（2）小括号：能够影响计算顺序，且可以嵌套。没有中括号、没有大括号，只有小括号。
（3）百分号：取余。只关心余数。
举例1：(取余)
<code>console.log(3 % 5);</code>
输出结果为3。
举例2：（注意运算符优先级）
<code>var a = 1 + 2 * 3 % 4 / 3;</code>
结果分析：
原式 = 1 + 6 % 4 / 3 = 1 + 2 / 3 = 1.66666666666666</p>
<p><strong>算数运算符的注意事项</strong>
（1）当对非Number类型的值进行运算（包括<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>）时，会将这些值转换为Number然后再运算。（注：<code>字符串 + Number</code>、<code>字符串 + 字符串</code>是特例，稍后再讲）
比如：</p>
<pre><code>    result1 = true + 1;  // 2 = 1+ 1
    result2 = true + false; // 1 = 1+ 0
    result3 = 1 + null; // 1 = 1+ 0
    result4 = 100 - '1' // 99
</code></pre>
<p>（2）任何值和NaN做运算的结果都是NaN。
（3）任何的值和字符串做加法运算，都会先转换为字符串，然后再做拼串操作。
比如：</p>
<pre><code>		result1 = 1 + 2 + '3'  // 33
		result2 = '1' + 2 + 3; // 123
</code></pre>
<p>我们可以利用这一特点，来将一个任意的数据类型转换为String：我们只需要为任意的数据类型 + 一个 &quot;&quot; 即可将其转换为String。这是一种<strong>隐式</strong>的类型转换，由浏览器自动完成，实际上它也是调用String()函数。也就是说，<code>c = c + &quot;&quot;</code> 等价于 <code>c = String(c)</code>。
（4）任何值做<code>-</code>、<code>*</code>、<code>/</code>运算时都会自动转换为Number。
我们可以利用这一特点，为一个值<code>-0</code>、<code>*1</code>、<code>/1</code>来将其转换为Number。原理和Number()函数一样，使用起来更加简单。</p>
<p><strong>乘方</strong>
如果想计算 <code>a 的 b 次方</code>，可以使用如下函数：
<code>Math.pow(a, b);</code>
Math的中文是“数学”，pow是“power 幂”。
<strong>举例1：</strong>
<img src="https://fuckupc.github.io/post-images/1552477579155.png" alt="">
代码实现：</p>
<pre><code>	var a = Math.pow(3, Math.pow(2, 2));
	console.log(a);
</code></pre>
<p><strong>举例2：</strong>
<img src="https://fuckupc.github.io/post-images/1552477589937.png" alt="">
代码实现：</p>
<pre><code>	var a = Math.pow(Math.pow(3, 2), 4);
	console.log(a);
</code></pre>
<p><strong>开方</strong>
如果想计算数值a的开二次方，可以使用如下函数：
<code>Math.sqrt(a);</code>
sqrt即“square 开方”。比如：
<code>var a = Math.sqrt(36);</code></p>
<p><strong>一元运算符</strong>
一元运算符，只需要一个操作数。
常见的一元运算符如下。
<strong>typeof</strong>
typeof就是典型的一元运算符，因为后面只跟一个操作数。
举例如下：</p>
<pre><code>	var a = '123';
	console.log(typeof a); // 打印结果：string
</code></pre>
<p><strong>正号 +</strong>
（1）正号不会对数字产生任何影响。比如说，<code>2</code>和<code>+2</code>是一样的。
（2）我们可以对一个其他的数据类型使用<code>+</code>，来将其转换为number【小技巧】。比如：</p>
<pre><code>    var a = true;
    a = +a;   // 注意这行代码的一元运算符操作
    console.log('a：' + a);
    console.log(typeof a);
    console.log('-----------------');
    var b = '18';
    b = +b;   // 注意这行代码的一元运算符操作
    console.log('b：' + b);
    console.log(typeof b);
</code></pre>
<p>打印结果：
<img src="https://fuckupc.github.io/post-images/1552477655792.png" alt=""></p>
<p><strong>负号<code>-</code></strong>
负号可以对数字进行取反。</p>
<h1 id="自增和自减">自增和自减</h1>
<p><strong>自增<code>++</code></strong>
自增分成两种：<code>a++</code>和<code>++a</code>。
（1）对于一个变量自增以后，原变量的值会<strong>立即</strong>自增1。也就是说，无论是 <code>a++</code> 还是<code>++a</code>，都会立即使原变量的值自增1。
（2）<strong>我们要注意的是</strong>：<code>a</code>是变量，而<code>a++</code>和<code>++a</code>是<strong>表达式</strong>。
那这两种自增，有啥区别呢？区别是：<code>a++</code> 和 <code>++a</code>的值不同：（也就是说，表达式的值不同）
<code>a++</code>的值等于原变量的值（a自增前的值）
<code>++a</code>的值等于新值 （a自增后的值）
<strong>自减 <code>--</code></strong>
原理同上。
<strong>代码举例</strong></p>
<pre><code>		var n1 = 10;
		var n2 = 20;

		var n = n1++; //n1 = 11  n1++ = 10

		console.log('n='+n);  // 10
		console.log('n1='+n1); //11

		n = ++n1 //n1 = 12  ++n1 =12
		console.log('n='+n); //12
		console.log('n1='+n1); //12

		n = n2--;// n2=19 n2--=20
		console.log('n='+n); //20
		console.log('n2='+n2); //19

		n = --n2; //n2=18 --n2 = 18
		console.log('n='+n); //18
		console.log('n2='+n2); //18
</code></pre>
<h1 id="逻辑运算符">逻辑运算符</h1>
<p>逻辑运算符有三个：
<code>&amp;&amp;</code> 与（且）：两个都为真，结果才为真。
<code>||</code>	或：只要有一个是真，结果就是真。
<code>!</code>非：对一个布尔值进行取反。
<strong>连比的写法：</strong>
来看看逻辑运算符连比的写法。
举例1：
<code>console.log(3 &lt; 2 &amp;&amp; 2 &lt; 4);</code>
输出结果为false。
举例2：（判断一个人的年龄是否在18~60岁之间）</p>
<pre><code>		var a = prompt(&quot;请输入您的年龄&quot;);
		alert(a&gt;=18 &amp;&amp; a&lt;= 65);
</code></pre>
<p>PS：上面的这个<code>a&gt;=18 &amp;&amp; a&lt;= 65</code>千万别想当然的写成 <code>18&lt;= a &lt;= 65</code>，没有这种语法。</p>
<p><strong>注意事项</strong>
（1）能参与逻辑运算的，都是布尔值。
（2）JS中的<code>&amp;&amp;</code>属于<strong>短路</strong>的与，如果第一个值为false，则不会看第二个值。举例：</p>
<pre><code>    //第一个值为true，会检查第二个值
    true &amp;&amp; alert(&quot;看我出不出来！！&quot;);  // 可以弹出 alert 框

    //第一个值为false，不会检查第二个值
    false &amp;&amp; alert(&quot;看我出不出来！！&quot;); // 不会弹出 alert 框
</code></pre>
<p>（3）JS中的<code>||</code> 属于<strong>短路</strong>的或，如果第一个值为true，则不会看第二个值。举例：</p>
<pre><code>    //第一个值为true，不会检查第二个值
    true || alert(&quot;看我出不出来！！&quot;);  // 不会弹出 alert 框

    //第一个值为false，会检查第二个值
    false || alert(&quot;看我出不出来！！&quot;); // 可以弹出 alert 框
</code></pre>
<p>（4）如果对<strong>非布尔值</strong>进行逻辑运算，则会<strong>先将其转换为布尔值</strong>，然后再操作。举例：</p>
<pre><code>    var a = 10;
    a = !a;
    console.log(a);  // false
    console.log(typeof a); // boolean
</code></pre>
<p>上面的例子，我们可以看到，对非布尔值进行<code>!</code> 操作之后，返回结果为布尔值。</p>
<h1 id="非布尔值的与或运算重要">非布尔值的与或运算【重要】</h1>
<blockquote>
<p>之所以重要，是因为在实际开发中，我们经常用这种代码做容错处理。
非布尔值进行<strong>与或运算</strong>时，会先将其转换为布尔值，然后再运算，但返回结果是<strong>原值</strong>。比如说：</p>
</blockquote>
<pre><code>    var result = 5 &amp;&amp; 6; // 运算过程：true &amp;&amp; true;
    console.log('result：' + result); // 打印结果：6（也就是说最后面的那个值。）
</code></pre>
<p>上方代码可以看到，虽然运算过程为布尔值的运算，但返回结果是原值。
那么，返回结果是哪个原值呢？我们来看一下。
<strong>与运算</strong>的返回结果：（以两个非布尔值的运算为例）
如果第一个值为true，则必然返回第二个值（所以说，如果所有的值都为true，则返回的是最后一个值）
如果第一个值为false，则直接返回第一个值
<strong>或运算</strong>的返回结果：（以两个非布尔值的运算为例）
如果第一个值为true，则直接返回第一个值
如果第一个值为false，则返回第二个值</p>
<p>实际开发中，我们经常是这样来处理容错的：
当成功调用一个接口后，针对返回的数据 result，假设我们用变量a 接收。通常的写法是这样的：（这里我只是举个例子）</p>
<pre><code>		if (result.resultCode == 0) {
			var a = result &amp;&amp; result.data &amp;&amp; result.data.imgUrl;
		}
</code></pre>
<p><strong>赋值运算符</strong>
可以将符号右侧的值赋值给符号左侧的变量。
举例：
<code>+=</code>。a += 5 等价于 a = a + 5
<code>-=</code>。a -= 5 等价于 a = a - 5
<code>*=</code>。a *= 5 等价于 a = a * 5
<code>/=</code>。a /= 5 等价于 a = a / 5
<code>%=</code>。a %= 5 等价于 a = a % 5</p>
<p><strong>关系运算符</strong>
通过关系运算符可以比较两个值之间的大小关系，如果关系成立它会返回true，如果关系不成立则返回false。
关系运算符有很多种，比如：</p>
<pre><code>		&gt;	大于号
		&lt;	小于号
		&gt;= 	大于或等于
		&lt;=  小于或等于
		== 	等于
		=== 全等于
		!=	不等于
		!== 不全等于
</code></pre>
<p><strong>关系运算符，得到的结果都是布尔值：要么是true，要么是false。</strong>
举例如下：
<code>var result = 5 &gt; 10; // false</code></p>
<p><strong>非数值的比较</strong>
（1）对于非数值进行比较时，会将其转换为数字然后再比较。
举例如下：</p>
<pre><code>		console.log(1 &gt; true); //false
		console.log(1 &gt;= true); //true
		console.log(1 &gt; &quot;0&quot;); //true

		//console.log(10 &gt; null); //true

		//任何值和NaN做任何比较都是false

		console.log(10 &lt;= &quot;hello&quot;); //false
		console.log(true &gt; false); //true
</code></pre>
<p>（2）特殊情况：如果符号两侧的值都是字符串时，<strong>不会</strong>将其转换为数字进行比较。比较两个字符串时，比较的是字符串的Unicode<strong>编码</strong>。【非常重要，这里是个大坑】
比较字符编码时，是一位一位进行比较。如果两位一样，则比较下一位，所以借用它可以来对英文进行排序。
PS：所以说，当你尝试去比较<code>&quot;123&quot;</code>和<code>&quot;56&quot;</code>这两个字符串时，你会发现，字符串&quot;56&quot;竟然比字符串&quot;123&quot;要大。也就是说，下面这样代码的打印结果，其实是true:（这个我们一定要注意，在日常开发中，很容易忽视）</p>
<pre><code>		// 比较两个字符串时，比较的是字符串的字符编码，所以可能会得到不可预期的结果
		console.log(&quot;56&quot; &gt; &quot;123&quot;);  // true
</code></pre>
<p>因此：当我们在比较两个字符串型的数字时，<strong>一定一定要先转型</strong>，比如 <code>parseInt()</code>。
（3）任何值和NaN做任何比较都是false。</p>
<p><strong><code>==</code>符号的强调</strong>
注意<code>==</code>这个符号，它是<strong>判断是否等于</strong>，而不是赋值。
（1）<code>==</code>这个符号，还可以验证字符串是否相同。例如：
<code>console.log(&quot;我爱你中国&quot; == &quot;我爱你中国&quot;);		//输出结果为true</code>
（2）== 这个符号并不严谨，会将不同类型的东西，<strong>转为相同类型</strong>进行比较（大部分情况下，都是转换为数字）。例如：</p>
<pre><code>	console.log(&quot;6&quot; == 6);		// 打印结果：true。这里的字符串&quot;6&quot;会先转换为数字6，然后再进行比较
	console.log(true == &quot;1&quot;);   // 打印结果：true
	console.log(0 == -0);       // 打印结果：true
	console.log(null == 0);   // 打印结果：true
</code></pre>
<p>（3）undefined 衍生自 null，所以这两个值做相等判断时，会返回true。
<code>console.log(undefined == null); //打印结果：true。</code>
（4）NaN不和任何值相等，包括他本身。
<code>console.log(NaN == NaN); //false</code>
问题：那如果我想判断 b的值是否为NaN，该怎么办呢？
答案：可以通过isNaN()函数来判断一个值是否是NaN。举例：
<code>console.log(isNaN(b)); //false</code>
如上方代码所示，如果 b 为 NaN，则返回true；否则返回false。</p>
<p><strong><code>===</code>全等符号的强调</strong>
如果要保证<strong>完全等于</strong>，我们就要用三个等号<code>===</code>。<strong>全等不会做类型转换</strong>。例如：</p>
<pre><code>			console.log(&quot;6&quot; === 6);		//false
			console.log(6 === 6);		//true
</code></pre>
<p>上述内容分析出：
<code>==</code>两个等号，不严谨，&quot;6&quot;和6是true。
<code>===</code>三个等号，严谨，&quot;6&quot;和6是false。
另外还有：<code>==</code>的反面是<code>!=</code>，<code>===</code>的反面是<code>!==</code>。例如：</p>
<pre><code>			console.log(3 != 8);	//true
			console.log(3 != &quot;3&quot;);	//false，因为3==&quot;3&quot;是true，所以反过来就是false。
			console.log(3 !== &quot;3&quot;);	//true，应为3===&quot;3&quot;是false，所以反过来是true。
</code></pre>
<p>&lt;&lt;Notes: This may make sense, but I prefer the normal way. --Cong Liu&gt;&gt;</p>
<p><strong>三元运算符</strong>
三元运算符也叫条件运算符。
语法：
<code>条件表达式?语句1:语句2;</code></p>
<p><strong>执行的流程：</strong>
条件运算符在执行时，首先对条件表达式进行求值：
如果该值为true，则执行语句1，并返回执行结果
如果该值为false，则执行语句2，并返回执行结果
如果条件的表达式的求值结果是一个非布尔值，会将其转换为布尔值然后再运算。</p>
<p><strong>运算符的优先级</strong>
运算符的优先级如下：（越往上，优先级越高）</p>
<pre><code>				.、[]、new
				()
				++、--
				!、~、+（单目）、-（单目）、typeof、void、delete
				%、*、/
				+（双目）、-（双目）
				&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;
				&lt;、&lt;=、&gt;、&gt;=
				==、!==、===
				&amp;
				^
				|
				&amp;&amp;
				||
				?:
				=、+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=、&amp;=、^=、|=
				,
</code></pre>
<p>备注：你在实际写代码的时候，如果不清楚哪个优先级更高，可以把括号运用上。</p>
<p><strong>Unicode 编码表</strong></p>
<blockquote>
<p>这一段中，我们来讲引申的内容：Unicode编码的使用。
1、在字符串中可以使用转义字符输入Unicode编码。格式如下：
<code>\u四位编码</code>
举例如下：</p>
</blockquote>
<pre><code>    console.log(&quot;\u2600&quot;);  // 这里的 2600 采用的是16进制
    console.log(&quot;\u2602&quot;);  // 这里的 2602 采用的是16进制。
</code></pre>
<p>打印结果：
<img src="https://fuckupc.github.io/post-images/1552477676963.png" alt=""></p>
<p>2、同样，我们可以在网页中使用Unicode编码。格式如下：
<code>&amp;#编码;</code>
PS：我们知道，Unicode编码采用的是16进制，但是，这里的编码需要使用10进制。
举例如下：
<code>&lt;h1 style=&quot;font-size: 100px;&quot;&gt;&amp;#9860;&lt;/h1&gt;</code>
打印结果：
<img src="https://fuckupc.github.io/post-images/1552477691096.png" alt=""></p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://fuckupc.github.io/tag/10cTD3yCu" class="tag">
                    Javascript
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://fuckupc.github.io/post/2q4W2AMp2">
                  <h3 class="post-title">
                    03.变量的强制类型转换
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  
  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '48a1f04adf6a01060905',
        clientSecret: 'f58a363eb32c4ae38493990e86e8bfd8654e1a17',
        repo: 'fuckupc.github.io',
        owner: 'fuckupc',
        admin: ['fuckupc'],
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
